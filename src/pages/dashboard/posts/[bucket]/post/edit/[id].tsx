import { Demo } from "@/components/demo";
import { Wallet } from "@/components/wallet";
import { useIsMounted } from "@/hooks/useIsMounted";
import styles from "@/styles/Home.module.css";
import { Inter } from "next/font/google";
import Head from "next/head";
import { useEffect, useRef, useState } from "react";
import { useAccount } from "wagmi";

import { PostGreenfield } from "@/components/greenfield";
import { Breadcrumb } from "@/components/breadcrumb";
import { useRouter } from "next/router";
import { client, selectSp } from "@/client";
import { getOffchainAuthKeys } from "@/utils/offchainAuth";

import dynamic from "next/dynamic";
let Editor = dynamic(() => import("@/components/editor"), {
  ssr: false,
});

const inter = Inter({ subsets: ["latin"] });

export default function Post() {
  const isMounted = useIsMounted();
  const { address, connector, isConnected } = useAccount();
  const [content, setContent] = useState<any>({});
  // const editorRef = useRef(null);
  const [info, setInfo] = useState<{
    bucketName: string;
    objectName: string;
  }>({
    bucketName: "",
    objectName: "",
  });

  const router = useRouter();
  const objectId = router.query.id;

  useEffect(() => {
    if (!address) return;
    if (!objectId) return;

    const getPostContent = async () => {
      if (!address) return;

      const spInfo = await selectSp();
      console.log("spInfo", spInfo);

      const provider = await connector?.getProvider();
      const offChainData = await getOffchainAuthKeys(address, provider);
      if (!offChainData) {
        alert("No offchain, please create offchain pairs first");
        return;
      }

      try {
        const listObjectTx = await client.object.listObjectsByIds({
          ids: [objectId] as string[],
        });

        if (listObjectTx.code === 0) {
          console.log(listObjectTx.body);
          const objectInfo =
            listObjectTx.body.GfSpListObjectsByIDsResponse.ObjectEntry[0].Value
              .ObjectInfo;

          console.log("Object ", objectInfo);
          setInfo({
            ...info,
            bucketName: objectInfo.BucketName,
            objectName: objectInfo.ObjectName,
          });

          const downloadFileTx = await client.object.getObjectPreviewUrl(
            {
              bucketName: objectInfo.BucketName,
              objectName: objectInfo.ObjectName,
              queryMap: {
                view: "1",
                "X-Gnfd-User-Address": address,
                "X-Gnfd-App-Domain": window.location.origin,
                "X-Gnfd-Expiry-Timestamp": "2024-09-03T09%3A23%3A39Z",
              },
            },
            {
              type: "EDDSA",
              address,
              domain: window.location.origin,
              seed: offChainData.seedString,
            }
          );

          const response = await fetch(downloadFileTx);
          if (!response.ok) {
            throw new Error(`Response status: ${response.status}`);
          }

          const json = await response.json();
          console.log("JSON", json);

          setContent(json);
        }
      } catch (err) {
        console.log(typeof err);
        if (err instanceof Error) {
          alert(err.message);
        }
        if (err && typeof err === "object") {
          alert(JSON.stringify(err));
        }
      }
    };

    getPostContent();
  }, [address, objectId]);

  if (!isMounted) return null;

  return (
    <>
      <Head>
        <title>Editor Greenfield App</title>
        <meta name="description" content="Generated by create Greenfield app" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
      </Head>
      <main className={`${styles.main} ${inter.className}`}>
        <Wallet />
        {isConnected && content && content.payload && (
          <>
            <Breadcrumb />
            <PostGreenfield data={content} objectInfo={info} readOnly={false}>
              <Editor
                data={content.payload}
                onChange={(e) => {}}
                holder="editor_create"
                readOnly={false}
                // editorRef={editorRef}
              />
            </PostGreenfield>
          </>
        )}
      </main>
    </>
  );
}
